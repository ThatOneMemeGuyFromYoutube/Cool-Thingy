<!DOCTYPE html>
<html>
<head>
    <title>Full Body Mesh Visualization</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #f0f0f0; }
        #canvas { position: absolute; top: 0; left: 0; border: 1px solid #ccc; }
        .container { position: relative; width: 100vw; height: 100vh; display: flex; justify-content: center; align-items: center; }
    </style>
</head>
<body>
    <div class="container">
        <h1>Welcome to the Full Body Mesh Visualization</h1>
        <button id="startButton">Start Camera</button>
        <button id="stopButton">Stop Camera</button>
        <video id="video"></video>
        <canvas id="canvas"></canvas>
    </div>

    <!-- Include MediaPipe and TensorFlow.js -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/holistic/holistic.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-core"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-converter"></script>

    <script>
        const videoElement = document.getElementById('video');
        const canvasElement = document.getElementById('canvas');
        const canvasCtx = canvasElement.getContext('2d');

        let holistic;
        let camera;

        function onResults(results) {
            canvasCtx.save();
            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);
            
            // Draw body connections
            if (results.poseLandmarks) {
                drawConnectors(canvasCtx, results.poseLandmarks, POSE_CONNECTIONS, 
                              {color: '#00FF00', lineWidth: 4});
                drawLandmarks(canvasCtx, results.poseLandmarks, 
                            {color: '#FF0000', lineWidth: 2});
            }

            // Draw hand connections
            if (results.leftHandLandmarks) {
                drawConnectors(canvasCtx, results.leftHandLandmarks, HAND_CONNECTIONS, 
                              {color: '#00FFFF', lineWidth: 2});
                drawLandmarks(canvasCtx, results.leftHandLandmarks, 
                            {color: '#FF00FF', lineWidth: 1});
            }
            if (results.rightHandLandmarks) {
                drawConnectors(canvasCtx, results.rightHandLandmarks, HAND_CONNECTIONS, 
                              {color: '#FFA500', lineWidth: 2});
                drawLandmarks(canvasCtx, results.rightHandLandmarks, 
                            {color: '#0000FF', lineWidth: 1});
            }

            // Draw face mesh
            if (results.faceLandmarks) {
                drawConnectors(canvasCtx, results.faceLandmarks, FACEMESH_TESSELATION, 
                              {color: '#C0C0C070', lineWidth: 1});
            }
            
            canvasCtx.restore();
        }

        async function setupCamera() {
            videoElement.srcObject = await navigator.mediaDevices.getUserMedia({
                video: { width: 1280, height: 720, facingMode: 'user' },
                audio: false
            });
            return new Promise((resolve) => {
                videoElement.onloadedmetadata = () => {
                    resolve(videoElement);
                };
            });
        }

        async function init() {
            await setupCamera();
            
            canvasElement.width = videoElement.videoWidth;
            canvasElement.videoHeight;

            holistic = new Holistic({
                locateFile: (file) => {
                    return `https://cdn.jsdelivr.net/npm/@mediapipe/holistic/${file}`;
                }
            });

            holistic.setOptions({
                modelComplexity: 1,
                smoothLandmarks: true,
                enableSegmentation: false,
                smoothSegmentation: true,
                refineFaceLandmarks: true,
                minDetectionConfidence: 0.5,
                minTrackingConfidence: 0.5
            });

            holistic.onResults(onResults);

            camera = new Camera(videoElement, {
                onFrame: async () => {
                    await holistic.send({image: videoElement});
                },
                width: 1280,
                height: 720
            });
        }

        const startButton = document.getElementById('startButton');
        const stopButton = document.getElementById('stopButton');

        startButton.addEventListener('click', () => {
            camera.start();
        });

        stopButton.addEventListener('click', () => {
            camera.stop();
        });

        init().catch(console.error);
    </script>
</body>
</html>
